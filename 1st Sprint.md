# 1차 스프린트

# 1차 스프린트 백로그

- SRS 작성
- 필수적 도메인 설계
- 계정관리 CRUD
    - 스프링 시큐리티 레이어 분리하기
    - 나중에 시큐리티 직접 AOP로 구현해볼거임
- 아키텍처 설계
- 테스트 코드 작성
- 구현
- 예외처리
- SRS 작성
- 필수적 도메인 설계
- 계정관리 CRUD
- 아키텍처 설계
- 테스트 코드 작성
    - 테스팅 기술 체득
    - 모킹 기술 체득
- 구현
- 예외처리

# 개발 기록

## 리포지토리 테스트 코드를 어떡하지?

- CRUD 에 관하여

### 예시: 회원 등록

- 사전조건
    - 중복되지 않은 이메일
    - 중복되지 않은 아이디
- 사후조건
    - 아무것도 반환하지 않음
    - DB에 회원 정보 저장됨
        - 이걸 모킹으로 해결해야 하나?
        - 모킹으로 em.persist() 호출 됐는지 확인하기?
- 근데 스프링 데이터 JPA의 핵심이 보일러플레이트 코드를 제거하는 것
    - 보일러플레이트 테스트 코드를 또 작성해야 하는건 이상하다
    - 스프링 데이터 JPA의 의도와는 맞지 않는 것

### 결론

- 단순 CRUD 는 테스트코드를 작성하지 말자
- `@Query` 나 `Querydsl` 을 사용한 커스텀 쿼리 메소드들만 테스트코드를 작성하자.

## 사용자 활성화/비활성화 정보를 어떻게 처리하지?

- 서비스 로직에서 그걸 해야하나?
- 보안의 활성화 비활성화 → 규약 위반
- 비즈니스 로직의 활성화 비활성화 → 사용자가 직접 개인 정보 변경
- 삭제된 계정 검색
- 비활성화된 계정 검색
- 활성화/비활성화 변경 테스트
- 삭제/복구 변경 테스트

## 예외 처리 어떻게 하지?

- 컨트롤러에서 `@ControllerAdvice` 로 해결해야 하나?
    - 잘못된 접근 → 403 Forbbiden
- 도메인 별로 예외처리 작성
- 테스트 코드에 해당 예외 처리하는 것 반영

[LocalDateTime 을 사용하는 함수의 테스팅 방법](https://go-gradually.tistory.com/94)

# 아키텍처 설계 & 계약 설계

### 사용자

- 상태
    - username
    - email
    - introduce
    - address
- 메소드
    - 주소 변경
    - 자기소개 변경

### 사용자 서비스

- 상태
    - 사용자 repo
    - 사용자 query repo
- 메소드
    - 사용자 추가
    - 사용자 제거
    - 사용자 정보 수정
    - 사용자 조회
    - 사용자 다수 조회

# 사전조건 & 사후조건 설정

- [x]  주소 변경
    - 사전조건
        - 주소 입력
        - 빈 문자열 가능
    - 사후조건
        - 성공: true
        - 실패: false
    - 빈 문자열 처리 어떤 방식으로 설계?
- [x]  자기소개 변경
    - 사전조건
        - 자기소개 입력
    - 사후조건
        - 성공: true
        - 실퍠: false
- [x]  사용자 username 검증
    - 사전조건
        - username 입력받음
    - 사후조건
        - 성공: true
        - 실패: false
- [x]  사용자 email 검증
    - 사전조건
        - email 입력받음
    - 사후조건
        - 성공: true
        - 실패: false
- [x]  사용자 추가
    - 사전조건
        - member 의 정보를 담은 객체 입력
    - 사후조건
        - 성공: 생성된 사용자 객체 반환
        - 실패
            - 이미 사용된 ID → ConflictUsernameException
            - 이미 사용된 Email → ConflictEmailException
            - 기본 검증은 성공했는데 계정 생성 시 오류 발생할 경우
- [x]  사용자 제거
    - 사전조건
        - 삭제하고자 하는 사용자 ID 입력
    - 사후조건
        - 반환 X
- [x]  사용자 정보 수정
    - 사전조건
        - 변경하고자 하는 사용자 정보 객체 입력
    - 사후조건
        - 성공: 사용자 객체 반환
        - 실패
            - TooLongIntroduceException
- [x]  사용자 조회
    - 사전조건
        - 사용자의 DB ID 입력
    - 사후조건
        - 해당 유저 객체 반환
        - 비어 있을 시, MemberNotExistException 반환
- [x]  가까운 사람 조회  → 친구 기능 구현 후 구현되어야 함
    - 사전조건
        - 검색하고 있는 사용자 ID 입력
        - 사용자가 검색창에 입력한 username 문자열 입력
    - 사후조건
        - 가까운 사람 순으로 리스트 출력
        - 비어있을 시, 빈 리스트 반환
    - 페이징 어떡하지, 100만개 들어오면 페이징 해야할텐데
        - 배치 페이징?
        - 이때가 OneToMany 페이징 차례인가?
        - 근데 그러면 안될텐데
- [x]  사용자 다수 조회
    - 사전조건
        - 검색하고 싶은 username 문자열 길이 1 이상
        - 사용자가 “가까운 사람”을 조회했는데, 해당 결과가 10건 이하이거나 스크롤로 새 유저를 찾을 때
        - 이전 페이지 사용자 ID
    - 사후조건
        - 아이디 순으로 출력
        - 비어있을 시, 빈 리스트 반환

# 테스트 코드 작성 & 구현

## 테스트 해야할 메소드 → 성공/실패/예외 케이스 리스트업

- 문서로는 그 모든 흐름이 간단하게 담기지 않는다
- 마인드맵, 논리 흐름도 적극 활용
    - 논리 흐름도 작성
    - 예외 먼저 테스트
    - 전체 성공 테스트
    - n개 규칙만 성공 테스트

### 도메인

- 주소 변경
    - [x]  테스트 코드 작성
    - [x]  구현
- 자기소개 변경
    - [x]  테스트 코드 작성
    - [x]  구현
- 멤버 생성
    - [x]  테스트 코드 작성
    - [x]  구현
- 멤버 주소 변경
    - [x]  테스트 코드 작성
    - [x]  구현

### 서비스

- Email 체크
    - [x]  테스트 코드 작성
    - [x]  구현
- username 체크
    - [x]  테스트 코드 작성
    - [x]  구현
- 사용자 추가
    - [x]  테스트 코드 작성
    - [x]  구현
- 사용자 제거
    - [x]  테스트 코드 작성
    - [x]  구현
- 사용자 조회
    - [x]  테스트 코드 작성
    - [x]  구현
- 사용자 다수 조회
    - [x]  테스트 코드 작성
        - [x]  마지막 사용자 이름과 리스트 묶어서 반환
            - 마지막 사용자 이름이 갱신이 되지 않는 문제 해결
    - [x]  구현

### 리포지토리

- 사용자 검색
    - [x]  테스트 코드 작성
    - [x]  구현

### 컨트롤러

- 컨트롤러 예외 처리
    - [x]  ConflictUsername
        - [x]  테스트 코드 작성
        - [x]  구현
    - [x]  ConflictEmail
        - [x]  테스트 코드 작성
        - [x]  구현
    - [x]  MemberNotFound
        - [x]  테스트 코드 작성
        - [x]  구현
- Member 생성
    - [x]  Member 생성
        - [x]  테스트 코드 작성
        - [x]  구현
    - [ ]  자기소개 변경
        - [ ]  테스트 코드 작성
        - [ ]  구현
    - [ ]  주소 변경
        - [ ]  테스트 코드 작성
        - [ ]  구현
    - [x]  회원 조회
        - [x]  테스트 코드 작성
        - [x]  구현
    - [x]  사용자 이름으로 회원 조회
        - [x]  테스트 코드 작성
        - [x]  구현
    - [x]  사용자 제거
        - [x]  테스트 코드 작성
        - [x]  구현
    - [x]  사용자 복구
        - [x]  테스트 코드 작성
        - [x]  구현
    - [x]  사용자 비활성화
        - [x]  테스트 코드 작성
        - [x]  구현
    - [x]  사용자 활성화
        - [x]  테스트 코드 작성
        - [x]  구현
    - [x]  이메일 검사
        - [x]  테스트 코드 작성
        - [x]  구현
    - [x]  사용자 이름 검사
        - [x]  테스트 코드 작성
        - [x]  구현

### 그 외

### 테스트 커버리지

# 회고

- 메소드 계약에 의한 설계의 중요성
    - 사전조건
    - 사후조건
- 계약은 날 위한 것이다.
    - 항상 계약을 먼저 작성해서
    - 다양한 “레이어 별“ 계약들이 한눈에 보이도록 작성한 뒤
    - 도메인, 레이어 코드를 작성하는 것
- 요구사항 분석 → 아키텍처 → 계약 → (테스트코드 → 구현) 반복

- 논리 흐름도를 통해 모든 경우의 수를 고려한 테스트 코드를 작성해야 한다
    - 각 경우의 수에 대한 빠진 테스트가 없도록
    - 각 메소드에 대해 호출한 다른 메소드들에 대한 케이스가 전부 처리되도록
- 하위 계층의 작업은 성공할 것이라고 가정하라
    - 현재 계층의 작업의 테스트에만 집중할 수 있도록
    - 하위 계층의 작업 실패는 예외로 던져서, 컨트롤러에서 일괄적으로 처리해라
        - 결과를 true/false 로 반환하면 안됨
        - 실패는 예외, 성공은 기대하는 결과값